---
- hosts: localhost
  tags:
    - e2e
    - rsync_tls
    - unprivileged
    - volumepopulator
    - volumegroup
  tasks:
    - name: Create namespace
      include_role:
        name: create_namespace

    - name: Probe cluster information
      include_role:
        name: gather_cluster_info

    - name: Define podSecurityContext
      ansible.builtin.set_fact:
        podSecurityContext:
          fsGroup: 5678
          runAsGroup: 5678
          runAsNonRoot: true
          runAsUser: 1234
          seccompProfile:
            type: RuntimeDefault
      when: not cluster_info.is_openshift

    # Simulating a volume group test
    # Volume group has 3 pvcs:
    # - PVC1: pvc-a   RD will use temp PVC name: temppvc-a
    # - PVC2: pvc-aa  RD will use temp PVC name: temppvc-aa
    # - PVC3: pvc-b   RD will use temp PVC name: temppvc-b

    - name: Create ReplicationDestination (w/ mSC)
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: volsync.backube/v1alpha1
          kind: ReplicationDestination
          metadata:
            name: test
            namespace: "{{ namespace }}"
          spec:
            rsyncTLS:
              copyMethod: Snapshot
              capacity: 1Gi
              accessModes:
                - ReadWriteOnce
              destinationPVCGroup:
                - name: data-aa
                  tempPVCName: temppvc-aa
                - name: data-b
                  tempPVCName: temppvc-b
                - name: data-a
                  tempPVCName: temppvc-a
              moverSecurityContext: "{{ podSecurityContext }}"
      when: podSecurityContext is defined

    - name: Create ReplicationDestination (w/o mSC)
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: volsync.backube/v1alpha1
          kind: ReplicationDestination
          metadata:
            name: test
            namespace: "{{ namespace }}"
          spec:
            rsyncTLS:
              copyMethod: Snapshot
              capacity: 1Gi
              accessModes:
                - ReadWriteOnce
              destinationPVCGroup:
                - name: data-aa
                  tempPVCName: temppvc-aa
                - name: data-b
                  tempPVCName: temppvc-b
                - name: data-a
                  tempPVCName: temppvc-a
      when: podSecurityContext is not defined

    - name: Wait for key and address to be ready
      kubernetes.core.k8s_info:
        api_version: volsync.backube/v1alpha1
        kind: ReplicationDestination
        name: test
        namespace: "{{ namespace }}"
      register: res_rd
      until: >
        res_rd.resources | length > 0 and
        res_rd.resources[0].status.rsyncTLS is defined and
        res_rd.resources[0].status.rsyncTLS.keySecret is defined and
        res_rd.resources[0].status.rsyncTLS.address is defined
      delay: 1
      retries: 300

    - name: Create source PVC1
      kubernetes.core.k8s:
        state: present
        definition:
          kind: PersistentVolumeClaim
          apiVersion: v1
          metadata:
            name: data-a
            namespace: "{{ namespace }}"
            labels:
              my-app-vgroup: "my-data"
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 1Gi

    - name: Create source PVC2
      kubernetes.core.k8s:
        state: present
        definition:
          kind: PersistentVolumeClaim
          apiVersion: v1
          metadata:
            name: data-aa
            namespace: "{{ namespace }}"
            labels:
              my-app-vgroup: "my-data"
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 1Gi

    - name: Create source PVC3
      kubernetes.core.k8s:
        state: present
        definition:
          kind: PersistentVolumeClaim
          apiVersion: v1
          metadata:
            name: data-b
            namespace: "{{ namespace }}"
            labels:
              my-app-vgroup: "my-data"
          spec:
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: 1Gi

    # Run affinity pod attached to both source & dest pvcs to make sure they end up in the
    # same availability zone so they can be mounted by a single pod later
    # when running compare-pvcs
    - name: Run pvc affinity pod for PVC1
      include_role:
        name: pvc_affinity_pod
      vars:
        pvc_names:
          - data-a
          - temppvc-a

    - name: Save affinity1 name
      ansible.builtin.set_fact:
        pvc_affinity_name1: "{{ pvc_affinity_name }}"

    - name: Run pvc affinity pod for PVC2
      include_role:
        name: pvc_affinity_pod
      vars:
        pvc_names:
          - data-aa
          - temppvc-aa

    - name: Save affinity2 name
      ansible.builtin.set_fact:
        pvc_affinity_name2: "{{ pvc_affinity_name }}"

    - name: Run pvc affinity pod for PVC3
      include_role:
        name: pvc_affinity_pod
      vars:
        pvc_names:
          - data-b
          - temppvc-b

    - name: Save affinity3 name
      ansible.builtin.set_fact:
        pvc_affinity_name3: "{{ pvc_affinity_name }}"

    # TODO: remove
    - name: Print out affinity stuff
      ansible.builtin.debug:
        msg: "affinity1 is: {{ pvc_affinity_name1 }} affinity2 is: {{ pvc_affinity_name2 }} affinity3 is: {{ pvc_affinity_name3 }}"

    - name: Write data into source PVC1
      include_role:
        name: write_to_pvc
      vars:
        data: 'data-AAAAAAAA1'
        path: '/datafile-a'
        pvc_name: 'data-a'

    - name: Write data into source PVC2
      include_role:
        name: write_to_pvc
      vars:
        data: 'data-AAAAAAAAAAAAAAAAAAA2'
        path: '/datafile-aa'
        pvc_name: 'data-aa'

    - name: Write more data into source PVC2
      include_role:
        name: write_to_pvc
      vars:
        data: 'The quick brown fox jumps over the lazy dog'
        path: '/.datafile-more-aa'
        pvc_name: 'data-aa'

    - name: Write data into source PVC3
      include_role:
        name: write_to_pvc
      vars:
        data: 'data-BBBBBBBBBBBBBBBBBBBB'
        path: '/datafile-b'
        pvc_name: 'data-b'

    - name: Save affinity1 name as affinity var to shutdown pod
      ansible.builtin.set_fact:
        pvc_affinity_name: "{{ pvc_affinity_name1 }}"

    - name: Shutdown pvc affinity1 pod
      include_role:
        name: pvc_affinity_pod
        tasks_from: "delete"

    - name: Save affinity2 name as affinity var to shutdown pod
      ansible.builtin.set_fact:
        pvc_affinity_name: "{{ pvc_affinity_name2 }}"

    - name: Shutdown pvc affinity2 pod
      include_role:
        name: pvc_affinity_pod
        tasks_from: "delete"

    - name: Save affinity3 name as affinity var to shutdown pod
      ansible.builtin.set_fact:
        pvc_affinity_name: "{{ pvc_affinity_name3 }}"

    - name: Shutdown pvc affinity3 pod
      include_role:
        name: pvc_affinity_pod
        tasks_from: "delete"

    - name: Create ReplicationSource (w/ mSC)
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: volsync.backube/v1alpha1
          kind: ReplicationSource
          metadata:
            name: source
            namespace: "{{ namespace }}"
          spec:
            sourcePVCGroup:
              selector:
                matchLabels:
                  my-app-vgroup: "my-data"
            trigger:
              schedule: "0 0 1 1 *"
            rsyncTLS:
              keySecret: "{{ res_rd.resources[0].status.rsyncTLS.keySecret }}"
              address: "{{ res_rd.resources[0].status.rsyncTLS.address }}"
              copyMethod: Snapshot
              moverSecurityContext: "{{ podSecurityContext }}"
      when: podSecurityContext is defined

    - name: Create ReplicationSource (w/o mSC)
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: volsync.backube/v1alpha1
          kind: ReplicationSource
          metadata:
            name: source
            namespace: "{{ namespace }}"
          spec:
            sourcePVCGroup:
              selector:
                matchLabels:
                  my-app-vgroup: "my-data"
            trigger:
              schedule: "0 0 1 1 *"
            rsyncTLS:
              keySecret: "{{ res_rd.resources[0].status.rsyncTLS.keySecret }}"
              address: "{{ res_rd.resources[0].status.rsyncTLS.address }}"
              copyMethod: Snapshot
      when: podSecurityContext is not defined

    - name: Check status of replicationsource
      kubernetes.core.k8s_info:
        api_version: volsync.backube/v1alpha1
        kind: ReplicationSource
        name: source
        namespace: "{{ namespace }}"
      register: res
      until: >
        res.resources | length > 0 and
        res.resources[0].status.lastSyncDuration is defined and
        res.resources[0].status.lastSyncTime is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-a'] is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-a'].result == "Successful" and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-a'].logs is search("sent.*bytes.*received.*bytes.*") and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-a'].logs is search("rsync completed in.*") and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-aa'] is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-aa'].result == "Successful" and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-aa'].logs is search("sent.*bytes.*received.*bytes.*") and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-aa'].logs is search("rsync completed in.*") and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-b'] is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-b'].result == "Successful" and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-b'].logs is search("sent.*bytes.*received.*bytes.*") and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-b'].logs is search("rsync completed in.*")
      delay: 1
      retries: 900

    - name: Wait for sync to complete
      kubernetes.core.k8s_info:
        api_version: volsync.backube/v1alpha1
        kind: ReplicationDestination
        name: test
        namespace: "{{ namespace }}"
      register: res
      until: >
        res.resources | length > 0 and
        res.resources[0].status.latestImage is defined and
        res.resources[0].status.latestImage.kind == "VolumeGroupSnapshot" and
        res.resources[0].status.latestVolumeGroupMoverStatus is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-a'] is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-a'].result == "Successful" and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-aa'] is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-aa'].result == "Successful" and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-b'] is defined and
        res.resources[0].status.latestVolumeGroupMoverStatus['data-b'].result == "Successful"
      delay: 1
      retries: 900

    # - name: Convert latestImage to PVC using VolumePopulator
    #   kubernetes.core.k8s:
    #     state: present
    #     definition:
    #       apiVersion: v1
    #       kind: PersistentVolumeClaim
    #       metadata:
    #         name: data-dest
    #         namespace: "{{ namespace }}"
    #       spec:
    #         accessModes:
    #           - ReadWriteOnce
    #         dataSourceRef:
    #           kind: ReplicationDestination
    #           apiGroup: volsync.backube
    #           name: test
    #         resources:
    #           requests:
    #             storage: 1Gi
    #   when: cluster_info.volumepopulator_supported

    # - name: Convert latestImage to PVC
    #   kubernetes.core.k8s:
    #     state: present
    #     definition:
    #       apiVersion: v1
    #       kind: PersistentVolumeClaim
    #       metadata:
    #         name: data-dest
    #         namespace: "{{ namespace }}"
    #       spec:
    #         accessModes:
    #           - ReadWriteOnce
    #         dataSource:
    #           kind: VolumeSnapshot
    #           apiGroup: snapshot.storage.k8s.io
    #           name: "{{ res.resources[0].status.latestImage.name }}"
    #         resources:
    #           requests:
    #             storage: 1Gi
    #   when: not cluster_info.volumepopulator_supported

    # TODO: need to actually restore the volume group snapshot first into PVCs
    # TODO: For now, just checking pvc contents against the temp replicationdestination pvc
    - name: Verify contents of PVC1
      include_role:
        name: compare_pvc_data
      vars:
        pvc1_name: data-a
        pvc2_name: temppvc-a
        timeout: 900

    - name: Verify contents of PVC2
      include_role:
        name: compare_pvc_data
      vars:
        pvc1_name: data-aa
        pvc2_name: temppvc-aa
        timeout: 900

    - name: Verify contents of PVC3
      include_role:
        name: compare_pvc_data
      vars:
        pvc1_name: data-b
        pvc2_name: temppvc-b
        timeout: 900
